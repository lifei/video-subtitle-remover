import abc
from ....utils.log_utils import get_logger as get_logger
from ..graph import Graph as Graph
from _typeshed import Incomplete
from abc import abstractmethod
from paddle.base import program_guard as program_guard
from paddle.base.backward import append_backward as append_backward
from paddle.base.framework import Parameter as Parameter, unique_name as unique_name
from paddle.distributed.auto_parallel.process_mesh import ProcessMesh as ProcessMesh
from paddle.distributed.auto_parallel.static.cluster_v2 import DeviceMesh as DeviceMesh
from paddle.distributed.auto_parallel.static.completion import Completer as Completer
from paddle.distributed.auto_parallel.static.cost import CostEstimator as CostEstimator
from paddle.distributed.auto_parallel.static.dist_attribute import OperatorDistAttr as OperatorDistAttr, TensorDistAttr as TensorDistAttr
from paddle.distributed.auto_parallel.static.dist_context import DistributedContext as DistributedContext
from paddle.distributed.auto_parallel.static.dist_tensor import DistributedTensor as DistributedTensor
from paddle.distributed.auto_parallel.static.process_group import get_world_process_group as get_world_process_group
from paddle.distributed.auto_parallel.static.utils import is_gradient_clip_op as is_gradient_clip_op, print_program_with_dist_attr as print_program_with_dist_attr
from paddle.distributed.fleet.meta_optimizers.common import OpRole as OpRole

def register_pattern(cls): ...

class BasePattern(Graph, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    @property
    def name(self): ...
    @abstractmethod
    def build(self): ...

class QKVPattern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class RowMatmulPattern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class FFNPattrern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class SharedWordEmbeddingPattern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class PositionEmbeddingPattern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class UnsqueezeDataPattern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class ReshapeDataPattern(BasePattern):
    name: str
    def __init__(self) -> None: ...
    def build(self) -> None: ...

class GraphUtil:
    @staticmethod
    def convert_to_graph(block): ...
    @staticmethod
    def match_pattern(pattern, graph): ...
    @staticmethod
    def match_all_patterns(graph): ...

class OperatorClusteringUtil:
    common_starts: Incomplete
    @staticmethod
    def get_ranks(seq): ...
    @staticmethod
    def get_suffixes(ranks): ...
    @staticmethod
    def get_heights(suffixes, seq): ...
    @staticmethod
    def get_longest_repeated_sub_seq(suffixes, heights, seq): ...
    @staticmethod
    def get_decomposed_sub_seq(seq): ...
    @staticmethod
    def replace_by_decomposed_seq(sub_seq, seq): ...
    @staticmethod
    def stop_replace(seq): ...

class ClusterPartitionUtil:
    @staticmethod
    def factorization(num): ...
    @staticmethod
    def complete_meshes(partitions: list, num: int): ...
    @staticmethod
    def partition_cluster(n: int, m: int, filter=...) -> list: ...

def convert_to_process_meshes(device_mesh: list) -> list: ...

class RuleBasedTuner:
    fwd_sub_programs: Incomplete
    sub_programs_dist_context: Incomplete
    fwd_sub_program_graphs: Incomplete
    full_main_program: Incomplete
    full_startup_program: Incomplete
    full_main_program_dist_context: Incomplete
    tensor_dist_attrs: Incomplete
    op_original_id_to_op: Incomplete
    op_original_id_to_idx: Incomplete
    op_original_id_to_grad_op_original_id: Incomplete
    process_meshes: Incomplete
    device_meshes_list: Incomplete
    stage_best_cost_of_dm: Incomplete
    stage_best_cost_of_pm: Incomplete
    layers: Incomplete
    def __init__(self, dist_context, mode: str = 'train', level: str = 'o1') -> None: ...
    @property
    def dist_context(self): ...
    @property
    def cluster(self): ...
    @property
    def mode(self): ...
    @property
    def level(self): ...
    def gen_full_program(self) -> None: ...
    def cluster_operators(self): ...
    def match_program(self, program) -> None: ...
    def gen_fwd_sub_programs_by_clone(self) -> None: ...
    def complete_sub_fwd_programs(self, process_mesh) -> None: ...
    def complete_sub_bwd_programs(self) -> None: ...
    def complete_sub_update_programs(self) -> None: ...
    def convert_process_mesh_to_key(self, process_mesh): ...
    def convert_device_mesh_to_key(self, device_mesh): ...
    def local_stage_pass(self, start, end, device_mesh): ...
    def combine_dist_contexts(self, dist_contexts): ...
    def prepare(self): ...
    def layer_placement_pass(self, stages, layers, device_meshes): ...
    def tune_o2(self): ...
    def tune_o1(self): ...
    def save_strategy(self, best_dist_context, path) -> None: ...
    def run_or_quit(self) -> None: ...
    def tune(self) -> None: ...
