from ..base.data_feeder import convert_dtype as convert_dtype
from _typeshed import Incomplete
from paddle.common_ops_import import default_main_program as default_main_program
from paddle.framework import in_dynamic_mode as in_dynamic_mode
from typing import NamedTuple

class ArrayWrapper:
    array: Incomplete
    def __init__(self, x) -> None: ...
    def append(self, x): ...
    def __getitem__(self, item): ...

class Decoder:
    def initialize(self, inits) -> None: ...
    def step(self, time, inputs, states, **kwargs) -> None: ...
    def finalize(self, outputs, final_states, sequence_lengths) -> None: ...
    @property
    def tracks_own_finished(self): ...

class BeamSearchDecoder(Decoder):
    cell: Incomplete
    embedding_fn: Incomplete
    output_fn: Incomplete
    start_token: Incomplete
    end_token: Incomplete
    beam_size: Incomplete
    def __init__(self, cell, start_token, end_token, beam_size, embedding_fn: Incomplete | None = None, output_fn: Incomplete | None = None) -> None: ...
    @staticmethod
    def tile_beam_merge_with_batch(x, beam_size): ...
    class OutputWrapper(NamedTuple('OutputWrapper', [('scores', Incomplete), ('predicted_ids', Incomplete), ('parent_ids', Incomplete)])): ...
    class StateWrapper(NamedTuple('StateWrapper', [('cell_states', Incomplete), ('log_probs', Incomplete), ('finished', Incomplete), ('lengths', Incomplete)])): ...
    kinf: float
    batch_size: Incomplete
    start_token_tensor: Incomplete
    end_token_tensor: Incomplete
    def initialize(self, initial_cell_states): ...
    def step(self, time, inputs, states, **kwargs): ...
    def finalize(self, outputs, final_states, sequence_lengths): ...
    @property
    def tracks_own_finished(self): ...

def dynamic_decode(decoder, inits: Incomplete | None = None, max_step_num: Incomplete | None = None, output_time_major: bool = False, impute_finished: bool = False, is_test: bool = False, return_length: bool = False, **kwargs): ...
