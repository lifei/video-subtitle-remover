import paddle
from .envs import ENV_CLEAN_CODE as ENV_CLEAN_CODE, ENV_COST_MODEL as ENV_COST_MODEL, ENV_SOT_LOG_LEVEL as ENV_SOT_LOG_LEVEL, ENV_STRICT_MODE as ENV_STRICT_MODE
from .paddle_api_config import break_graph_set as break_graph_set, paddle_api_list as paddle_api_list, paddle_api_module_prefix as paddle_api_module_prefix
from _typeshed import Incomplete
from collections.abc import Generator
from enum import Enum
from paddle.framework import Program as Program
from paddle.utils import flatten as flatten, map_structure as map_structure
from typing import Any, Generic, Iterable, Iterator, TypeVar

T = TypeVar('T')

class Singleton(Generic[T]):
    def __init__(self, cls: type[T]) -> None: ...
    def __call__(self) -> T: ...

class NameGenerator:
    counter: int
    prefix: Incomplete
    def __init__(self, prefix) -> None: ...
    def next(self): ...
    def match_name(self, name: str) -> bool: ...

class TmpNameRecords:
    name_generator: Incomplete
    tmp_names_record: Incomplete
    def __init__(self) -> None: ...
    def next_name(self): ...
    def add_tmp_var(self, expr): ...

def tmp_name_guard() -> Generator[None]: ...
def current_tmp_name_records(): ...

class ResumeFnNameFactory:
    gen: Incomplete
    def __init__(self) -> None: ...
    def next(self): ...

def log(level, *args) -> None: ...
def log_do(level, fn) -> None: ...
def log_format(level, str, *args) -> None: ...
def no_eval_frame(func): ...
def is_paddle_api(func): ...
def is_builtin_fn(fn): ...
def in_paddle_module(func): ...
def is_break_graph_api(func): ...
def map_if(*structures, pred, true_fn, false_fn): ...
def flatten_extend(structure) -> Generator[Incomplete]: ...
def map_if_extend(structure, pred, true_fn, false_fn): ...
def count_if(*structures, pred): ...

class Cache:
    cache: Incomplete
    hit_num: int
    def __init__(self, weak: bool = False) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def clear(self) -> None: ...
    def key_fn(self, *args, **kwargs) -> None: ...
    def value_fn(self, *args, **kwargs) -> None: ...

def execute_time(func): ...
def meta_str(shape, dtype, stop_gradient): ...
def is_strict_mode(): ...
def is_clean_code() -> bool: ...
def list_find_index_by_id(li: list[Any], item: Any) -> int: ...
def list_contain_by_id(li: list[Any], item: Any) -> int: ...
def get_unbound_method(obj, name): ...

class GraphLogger:
    graph_num: int
    op_num: int
    graphs: list[Program]
    ops: list[paddle.base.framework.Operator]
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def get_graph_num(self): ...
    def get_op_num(self): ...
    def add_subgraph(self, program: Program): ...
    def add_subgprah_info(self, strs) -> None: ...
    def print_info(self) -> None: ...

class SotUndefinedVar: ...

def hashable(obj): ...

class OrderedSet(Generic[T]):
    def __init__(self, items: Iterable[T] | None = None) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def __or__(self, other: OrderedSet[T]) -> OrderedSet[T]: ...
    def __ior__(self, other: OrderedSet[T]): ...
    def __and__(self, other: OrderedSet[T]) -> OrderedSet[T]: ...
    def __iand__(self, other: OrderedSet[T]): ...
    def __sub__(self, other: OrderedSet[T]) -> OrderedSet[T]: ...
    def __isub__(self, other: OrderedSet[T]): ...
    def add(self, item: T): ...
    def remove(self, item: T): ...
    def __contains__(self, item: T) -> bool: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...

class StepState(Enum):
    COLLECT_INFO = 1
    RUN_SOT = 2
    RUN_DYN = 3

class StepInfo:
    REQUIRED_DYN_INFOS: int
    REQUIRED_SOT_INFOS: int
    USED_DYN_INFOS: int
    COLLECT_INFO_MAX_STEP: int
    CV_BOUNDARY: float
    BACK_TRACE_STEPS: int
    step_count: int
    state: Incomplete
    dyn_time_costs: Incomplete
    avg_dyn_time: int
    sot_time_costs: Incomplete
    sot_step: int
    def __init__(self) -> None: ...
    def add_dynamic_time_info(self, time_cost) -> None: ...
    def add_sot_time_info(self, time_cost, current_code) -> None: ...
    def need_back_trace(self): ...
    def need_dynamic_info(self): ...

class StepInfoManager:
    step_record: Incomplete
    current_code: Incomplete
    current_step_info: Incomplete
    def __init__(self) -> None: ...
    def step_guard(self, code) -> Generator[None]: ...
    def sot_step(self) -> None: ...
    def collect_info(self, impl_dynamic, impl_sot, /, *args, **kwargs): ...
    @property
    def need_back_trace(self): ...
    @property
    def current_step(self): ...
    @property
    def current_state(self): ...
    def clear(self) -> None: ...
