import dataclasses
import dis
import types
from ...utils import InnerError as InnerError
from .opcode_info import ABS_JUMP as ABS_JUMP, ALL_JUMP as ALL_JUMP, REL_BWD_JUMP as REL_BWD_JUMP, REL_JUMP as REL_JUMP
from _typeshed import Incomplete
from typing import Any

@dataclasses.dataclass
class Instruction:
    opcode: int
    opname: str
    arg: int | None
    argval: Any
    offset: int | None = ...
    starts_line: int | None = ...
    is_jump_target: bool = ...
    jump_to: Instruction | None = ...
    is_generated: bool = ...
    first_ex_arg: Instruction | None = ...
    ex_arg_for: Instruction | None = ...
    def __hash__(self): ...
    def __eq__(self, instr): ...

def gen_instr(name, arg: Incomplete | None = None, argval: Incomplete | None = None, gened: bool = True, jump_to: Incomplete | None = None): ...
def convert_instruction(instr: dis.Instruction) -> Instruction: ...
def get_instructions(code: types.CodeType) -> list[Instruction]: ...
def modify_instrs(instructions: list[Instruction]) -> None: ...
def reset_offset(instructions: list[Instruction]) -> None: ...
def correct_jump_direction(instr: Instruction, arg: int) -> Instruction: ...
def relocate_jump_target(instructions: list[Instruction]) -> None: ...
def modify_extended_args(instructions: list[Instruction]) -> bool: ...
def modify_vars(instructions, code_options) -> None: ...
def calc_offset_from_bytecode_offset(bytecode_offset: int, instructions: list[dis.Instruction] | list[Instruction]) -> int: ...
def replace_instr(instructions, instr, new_instr) -> None: ...
def instrs_info(instrs, mark: Incomplete | None = None, range: Incomplete | None = None, want_str: bool = True): ...
def calc_stack_effect(instr: Instruction, *, jump: bool | None = None) -> int: ...
