from ....utils.exceptions import FallbackError as FallbackError, InnerError as InnerError
from ..dispatcher import Dispatcher as Dispatcher
from ..function_graph import FunctionGraph as FunctionGraph
from ..guard import StringifyExpression as StringifyExpression, check_guard as check_guard
from ..mutable_data import MutableDictLikeData as MutableDictLikeData, MutableListLikeData as MutableListLikeData
from ..pycode_generator import PyCodeGen as PyCodeGen
from ..tracker import ConstTracker as ConstTracker, DanglingTracker as DanglingTracker, DummyTracker as DummyTracker, GetItemTracker as GetItemTracker, GetIterTracker as GetIterTracker, Tracker as Tracker
from .base import ConstTypes as ConstTypes, VariableBase as VariableBase, VariableFactory as VariableFactory
from .basic import ConstantVariable as ConstantVariable
from .callable import BuiltinVariable as BuiltinVariable, UserDefinedFunctionVariable as UserDefinedFunctionVariable
from _typeshed import Incomplete
from typing import Any

class ContainerVariable(VariableBase):
    @property
    def init_value(self): ...
    def get_items(self) -> list[VariableBase]: ...
    def get_wrapped_items(self) -> None: ...
    def __len__(self) -> int: ...
    def len(self): ...
    def __bool__(self) -> bool: ...
    def bool(self): ...
    def make_stringify_guard(self) -> list[StringifyExpression]: ...

class ListVariable(ContainerVariable):
    proxy: Incomplete
    value: Incomplete
    def __init__(self, val_list: list[VariableBase], graph: FunctionGraph, tracker: Tracker) -> None: ...
    def proxy_getter(self, proxy: MutableListLikeData, key: Any): ...
    def get_py_value(self, allow_tensor: bool = False): ...
    def get_py_type(self): ...
    def get_items(self): ...
    def get_wrapped_items(self): ...
    def get_iter(self): ...
    @property
    def main_info(self) -> dict[str, Any]: ...
    def __len__(self) -> int: ...
    def getitem(self, key): ...
    def setitem(self, key, value): ...
    def __delitem__(self, key) -> None: ...
    def delitem(self, key): ...
    def insert(self, index: int, value: VariableBase): ...
    def append(self, value: VariableBase): ...
    def extend(self, data): ...
    def concat(self, list_): ...
    def repeat(self, length): ...
    def pop(self, index: ConstantVariable | None = None): ...
    def copy(self): ...
    def clear(self): ...
    def remove(self, value): ...
    def sort(self, key: Incomplete | None = None, reverse: Incomplete | None = None): ...
    def reverse(self): ...
    def count(self, value: VariableBase): ...
    def index(self, value: VariableBase): ...
    def max(self): ...
    def min(self): ...
    def getattr(self, name: str, default: Incomplete | None = None): ...
    def from_value(value: Any, graph: FunctionGraph, tracker: Tracker): ...

class TupleVariable(ContainerVariable):
    proxy: Incomplete
    value: Incomplete
    def __init__(self, val_tuple: tuple[VariableBase, ...], graph: FunctionGraph, tracker: Tracker) -> None: ...
    def getattr(self, name: str, default: Incomplete | None = None): ...
    def proxy_getter(self, proxy: MutableListLikeData, key: Any): ...
    def get_py_value(self, allow_tensor: bool = False): ...
    def get_py_type(self): ...
    def get_items(self): ...
    def get_wrapped_items(self): ...
    def get_iter(self): ...
    @property
    def main_info(self) -> dict[str, Any]: ...
    def __len__(self) -> int: ...
    def getitem(self, key): ...
    def setitem(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def delitem(self, key) -> None: ...
    def concat(self, tuple_): ...
    def repeat(self, length): ...
    def count(self, value: VariableBase): ...
    def index(self, value: VariableBase): ...
    def from_value(value: Any, graph: FunctionGraph, tracker: Tracker): ...

class RangeVariable(ContainerVariable):
    value: Incomplete
    def __init__(self, val_range: range, graph: FunctionGraph, tracker: Tracker) -> None: ...
    def get_py_type(self): ...
    def get_py_value(self, allow_tensor: bool = False): ...
    def getitem(self, key): ...
    def get_items(self): ...
    def get_wrapped_items(self): ...
    def get_iter(self): ...
    def __len__(self) -> int: ...
    def from_value(value: Any, graph: FunctionGraph, tracker: Tracker): ...
    def make_stringify_guard(self) -> list[StringifyExpression]: ...
    @property
    def debug_name(self) -> str: ...
    @debug_name.setter
    def debug_name(self, name) -> None: ...
    @property
    def main_info(self) -> dict[str, Any]: ...

class DictVariable(ContainerVariable):
    proxy: Incomplete
    value: Incomplete
    def __init__(self, val_dict: dict[object, VariableBase], graph: FunctionGraph, tracker: Tracker) -> None: ...
    def proxy_getter(self, proxy: MutableDictLikeData, key: Any): ...
    def get_py_value(self, allow_tensor: bool = False): ...
    def get_py_type(self): ...
    def get_items(self): ...
    def get_wrapped_items(self): ...
    def get_iter(self): ...
    @property
    def main_info(self) -> dict[str, Any]: ...
    def __len__(self) -> int: ...
    def get(self, key, default: Incomplete | None = None): ...
    def getitem(self, key): ...
    def setitem(self, key, value): ...
    def clear(self): ...
    def __delitem__(self, key) -> None: ...
    def delitem(self, key): ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...
    def update(self, data: DictVariable): ...
    def copy(self): ...
    def setdefault(self, key, default: Incomplete | None = None): ...
    def pop(self, key, default: Incomplete | None = None): ...
    def popitem(self): ...
    def getattr(self, name: str, default: Incomplete | None = None): ...
    def from_value(value: Any, graph: FunctionGraph, tracker: Tracker): ...
