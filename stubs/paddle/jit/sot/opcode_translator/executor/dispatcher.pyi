import inspect
from ...utils import InnerError as InnerError, NameGenerator as NameGenerator, hashable as hashable
from _typeshed import Incomplete
from functools import cached_property as cached_property
from typing import Any, Callable, TypeVar

T = TypeVar('T')
Args = tuple[T, ...]
Kwargs = dict[str, T]

def format_type(type_: type[Any] | tuple[type[Any], ...]) -> str: ...
def format_param(param: Parameter) -> str: ...
def convert_annotation_to_type(type_str: str) -> tuple[type[Any], ...]: ...

class Parameter:
    name_gen: Incomplete
    annotation: str
    name: str
    kind: Incomplete
    default: Incomplete
    def __init__(self, annotation: str, *, kind: inspect._ParameterKind = ..., name: str | None = None, default: Any = ...) -> None: ...
    def to_parameter(self) -> inspect.Parameter: ...
    @cached_property
    def type(self) -> tuple[type[Any], ...]: ...
    def match_arg(self, arg: Any) -> bool: ...
    @staticmethod
    def from_str(annotation: str) -> Parameter: ...
    @staticmethod
    def from_parameter(parameter: inspect.Parameter) -> Parameter: ...

def optional(annotation: str, default: Any = None) -> Parameter: ...

class Pattern:
    parameters: dict[str, Parameter]
    signature: inspect.Signature
    def __init__(self, *parameters: Parameter) -> None: ...
    def match_inputs(self, /, *args: Any, **kwargs: Any) -> bool: ...

class Dispatcher:
    handlers: dict[Callable[..., Any], list[tuple[Pattern, Callable[..., Any]]]]
    graph: Any
    @classmethod
    def register(cls, fn: Callable[..., Any], parameters: tuple[str | Parameter, ...], handler: Callable[..., Any]): ...
    @classmethod
    def register_decorator(cls, fn: Callable[..., Any]): ...
    @classmethod
    def call(cls, fn, *args, **kwargs): ...
    @classmethod
    def dispatch(cls, fn: Callable[..., Any], *args: Any, **kwargs: Any) -> Callable[..., Any] | None: ...
