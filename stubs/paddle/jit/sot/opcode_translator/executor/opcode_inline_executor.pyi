from ...profiler import event_register as event_register
from ...utils import BreakGraphError as BreakGraphError, log as log
from ..instruction_utils import Instruction as Instruction
from .guard import StringifyExpression as StringifyExpression, union_free_vars as union_free_vars
from .opcode_executor import OpcodeExecutorBase as OpcodeExecutorBase, Stop as Stop
from .pycode_generator import PyCodeGen as PyCodeGen
from .tracker import ConstTracker as ConstTracker, DanglingTracker as DanglingTracker, DummyTracker as DummyTracker, Tracker as Tracker
from .variables import CellVariable as CellVariable, FunctionGlobalVariable as FunctionGlobalVariable, FunctionVariable as FunctionVariable, IterVariable as IterVariable, SequenceIterVariable as SequenceIterVariable, VariableBase as VariableBase
from _typeshed import Incomplete
from collections.abc import Generator

class FunctionGlobalTracker(Tracker):
    fn: Incomplete
    name: Incomplete
    def __init__(self, fn: FunctionVariable, name: str) -> None: ...
    def gen_instructions(self, codegen: PyCodeGen): ...
    def trace_value_from_frame(self) -> StringifyExpression: ...

class FunctionClosureTracker(Tracker):
    fn: Incomplete
    idx: Incomplete
    def __init__(self, fn: FunctionVariable, idx: int) -> None: ...
    def gen_instructions(self, codegen: PyCodeGen): ...
    def trace_value_from_frame(self): ...

def signature_clear_guard(fn, name) -> Generator[None]: ...

class OpcodeInlineExecutor(OpcodeExecutorBase):
    return_value: VariableBase | None
    def __init__(self, fn_variable: FunctionVariable, *args, **kwargs) -> None: ...
    def inline_call(self) -> VariableBase: ...
    def RETURN_VALUE(self, instr: Instruction): ...
    def FOR_ITER(self, instr: Instruction): ...
