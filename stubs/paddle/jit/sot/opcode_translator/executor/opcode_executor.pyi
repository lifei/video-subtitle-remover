import types
from ...profiler import EventGuard as EventGuard, event_register as event_register
from ...psdb import NO_BREAKGRAPH_CODES as NO_BREAKGRAPH_CODES
from ...utils import BreakGraphError as BreakGraphError, ENV_MIN_GRAPH_SIZE as ENV_MIN_GRAPH_SIZE, FallbackError as FallbackError, InnerError as InnerError, OrderedSet as OrderedSet, SotUndefinedVar as SotUndefinedVar, log as log, log_do as log_do
from ..custom_code import CustomCode as CustomCode
from ..instruction_utils import Instruction as Instruction, Space as Space, analysis_inputs as analysis_inputs, analysis_used_names_with_space as analysis_used_names_with_space, calc_stack_effect as calc_stack_effect, get_instructions as get_instructions
from ..instruction_utils.opcode_info import JumpDirection as JumpDirection, PopJumpCond as PopJumpCond
from .dispatch_functions import operator_BAD as operator_BAD, operator_exception_match as operator_exception_match, operator_in as operator_in, operator_is_none as operator_is_none, operator_is_not_none as operator_is_not_none, operator_not_in as operator_not_in
from .dispatcher import Dispatcher as Dispatcher
from .function_graph import FunctionGraph as FunctionGraph
from .pycode_generator import PyCodeGen as PyCodeGen
from .tracker import CellTracker as CellTracker, ConstTracker as ConstTracker, DanglingTracker as DanglingTracker, DummyTracker as DummyTracker, LocalTracker as LocalTracker
from .variable_stack import VariableStack as VariableStack
from .variables import BuiltinVariable as BuiltinVariable, CellVariable as CellVariable, ConstantVariable as ConstantVariable, ContainerVariable as ContainerVariable, DictVariable as DictVariable, GlobalVariable as GlobalVariable, ListVariable as ListVariable, MethodVariable as MethodVariable, NullVariable as NullVariable, SequenceIterVariable as SequenceIterVariable, SliceVariable as SliceVariable, TensorVariable as TensorVariable, TupleVariable as TupleVariable, UserDefinedFunctionVariable as UserDefinedFunctionVariable, VariableBase as VariableBase, VariableFactory as VariableFactory
from _typeshed import Incomplete
from dataclasses import dataclass
from typing import Any, Callable

SUPPORT_COMPARE_OP: Incomplete

@dataclass
class Stop:
    state: str

def tos_op_wrapper(fn: Callable): ...
def tos_inplace_op_wrapper(fn: Callable): ...
def pop_jump_if_op_wrapper(fns: list[Callable[[Any], Any]]): ...
def jump_break_graph_decorator(normal_jump: Callable): ...
def call_break_graph_decorator(push_n: int | Callable[[int | None], int]): ...
def fallback_when_occur_error(fn: Callable): ...

class OpcodeExecutorBase:
    class EmptyCode: ...
    call_stack: list[OpcodeExecutorBase]
    empty_code: Incomplete
    @staticmethod
    def validate_value(value) -> None: ...
    stack: Incomplete
    new_code: types.CodeType | None
    guard_fn: Incomplete
    stop_state: Incomplete
    def __init__(self, code: types.CodeType, graph: FunctionGraph) -> None: ...
    def check_code_simulatable(self) -> None: ...
    def print_sir(self) -> None: ...
    def transform(self) -> None: ...
    def get_var(self, name: str): ...
    def has_var(self, name: str, space: str = 'any'): ...
    def pop_call_stack_until_self(self) -> None: ...
    @staticmethod
    def error_message_summary(original_error: Exception) -> str: ...
    def run(self) -> None: ...
    def step(self, instr: Instruction): ...
    def indexof(self, instr: Instruction): ...
    def jump_to(self, instr: Instruction): ...
    def COPY(self, instr: Instruction): ...
    def DUP_TOP(self, instr: Instruction): ...
    def DUP_TOP_TWO(self, instr: Instruction): ...
    def ROT_N(self, instr: Instruction): ...
    def POP_TOP(self, instr: Instruction): ...
    def PUSH_NULL(self, instr: Instruction): ...
    def ROT_TWO(self, instr: Instruction): ...
    def ROT_THREE(self, instr: Instruction): ...
    def ROT_FOUR(self, instr: Instruction): ...
    def RESUME(self, instr: Instruction): ...
    def SWAP(self, instr: Instruction): ...
    UNARY_POSITIVE: Incomplete
    UNARY_NEGATIVE: Incomplete
    UNARY_NOT: Incomplete
    UNARY_INVERT: Incomplete
    BINARY_POWER: Incomplete
    BINARY_MULTIPLY: Incomplete
    BINARY_MATRIX_MULTIPLY: Incomplete
    BINARY_FLOOR_DIVIDE: Incomplete
    BINARY_TRUE_DIVIDE: Incomplete
    BINARY_MODULO: Incomplete
    BINARY_ADD: Incomplete
    BINARY_SUBTRACT: Incomplete
    BINARY_LSHIFT: Incomplete
    BINARY_RSHIFT: Incomplete
    BINARY_AND: Incomplete
    BINARY_OR: Incomplete
    BINARY_XOR: Incomplete
    def BINARY_OP(self, instr: Instruction): ...
    def BINARY_SUBSCR(self, instr: Instruction): ...
    INPLACE_POWER: Incomplete
    INPLACE_MULTIPLY: Incomplete
    INPLACE_MATRIX_MULTIPLY: Incomplete
    INPLACE_FLOOR_DIVIDE: Incomplete
    INPLACE_TRUE_DIVIDE: Incomplete
    INPLACE_MODULO: Incomplete
    INPLACE_ADD: Incomplete
    INPLACE_SUBTRACT: Incomplete
    INPLACE_LSHIFT: Incomplete
    INPLACE_RSHIFT: Incomplete
    INPLACE_AND: Incomplete
    INPLACE_OR: Incomplete
    INPLACE_XOR: Incomplete
    def NOP(self, instr: Instruction): ...
    def LOAD_ATTR(self, instr: Instruction): ...
    def LOAD_CONST(self, instr: Instruction): ...
    def MAKE_CELL(self, instr: Instruction): ...
    def LOAD_CLOSURE(self, instr: Instruction): ...
    def LOAD_DEREF(self, instr: Instruction): ...
    def COPY_FREE_VARS(self, instr: Instruction): ...
    def LOAD_FAST(self, instr: Instruction): ...
    def DELETE_FAST(self, instr: Instruction): ...
    def LOAD_GLOBAL(self, instr: Instruction): ...
    def LOAD_METHOD(self, instr: Instruction): ...
    def STORE_ATTR(self, instr: Instruction): ...
    def DELETE_ATTR(self, instr: Instruction): ...
    def STORE_DEREF(self, instr: Instruction): ...
    def STORE_FAST(self, instr: Instruction): ...
    def STORE_GLOBAL(self, instr: Instruction): ...
    def DELETE_GLOBAL(self, instr: Instruction): ...
    def STORE_SUBSCR(self, instr: Instruction): ...
    def DELETE_SUBSCR(self, instr: Instruction): ...
    def BUILD_LIST(self, instr: Instruction): ...
    def BUILD_TUPLE(self, instr: Instruction): ...
    def BUILD_STRING(self, instr: Instruction): ...
    def BUILD_SLICE(self, instr: Instruction): ...
    def build_map(self, keys: list[VariableBase], values: list[VariableBase]) -> VariableBase: ...
    def BUILD_MAP(self, instr: Instruction): ...
    def BUILD_CONST_KEY_MAP(self, instr: Instruction): ...
    def build_seq_unpack(self, instr: Instruction): ...
    def BUILD_TUPLE_UNPACK_WITH_CALL(self, instr: Instruction): ...
    def BUILD_TUPLE_UNPACK(self, instr: Instruction): ...
    def BUILD_LIST_UNPACK(self, instr: Instruction): ...
    def BUILD_MAP_UNPACK(self, instr: Instruction): ...
    def BUILD_MAP_UNPACK_WITH_CALL(self, instr: Instruction): ...
    def PRECALL(self, instr: Instruction): ...
    def KW_NAMES(self, instr: Instruction): ...
    def CALL(self, instr: Instruction): ...
    def CALL_FUNCTION(self, instr: Instruction): ...
    def CALL_FUNCTION_KW(self, instr: Instruction): ...
    def CALL_FUNCTION_EX(self, instr: Instruction): ...
    def CALL_METHOD(self, instr: Instruction): ...
    def COMPARE_OP(self, instr: Instruction): ...
    def IS_OP(self, instr: Instruction): ...
    def MAKE_FUNCTION(self, instr: Instruction): ...
    def GET_ITER(self, instr: Instruction): ...
    def JUMP_ABSOLUTE(self, instr: Instruction): ...
    def JUMP_FORWARD(self, instr: Instruction): ...
    def JUMP_BACKWARD(self, instr: Instruction): ...
    def JUMP_BACKWARD_NO_INTERRUPT(self, instr: Instruction): ...
    def CONTAINS_OP(self, instr: Instruction): ...
    def JUMP_IF_FALSE_OR_POP(self, instr: Instruction): ...
    def JUMP_IF_TRUE_OR_POP(self, instr: Instruction): ...
    POP_JUMP_IF_FALSE: Incomplete
    POP_JUMP_FORWARD_IF_FALSE = POP_JUMP_IF_FALSE
    POP_JUMP_BACKWARD_IF_FALSE = POP_JUMP_IF_FALSE
    POP_JUMP_IF_TRUE: Incomplete
    POP_JUMP_FORWARD_IF_TRUE = POP_JUMP_IF_TRUE
    POP_JUMP_BACKWARD_IF_TRUE = POP_JUMP_IF_TRUE
    POP_JUMP_FORWARD_IF_NONE: Incomplete
    POP_JUMP_BACKWARD_IF_NONE = POP_JUMP_FORWARD_IF_NONE
    POP_JUMP_FORWARD_IF_NOT_NONE: Incomplete
    POP_JUMP_BACKWARD_IF_NOT_NONE = POP_JUMP_FORWARD_IF_NOT_NONE
    def UNPACK_SEQUENCE(self, instr: Instruction): ...
    def UNPACK_EX(self, instr: Instruction): ...
    def FORMAT_VALUE(self, instr: Instruction): ...
    def DICT_UPDATE(self, instr: Instruction): ...
    def DICT_MERGE(self, instr: Instruction): ...
    def LIST_APPEND(self, instr: Instruction): ...
    def MAP_ADD(self, instr: Instruction): ...
    def LIST_EXTEND(self, instr: Instruction): ...
    def LIST_TO_TUPLE(self, instr: Instruction): ...

class OpcodeExecutor(OpcodeExecutorBase):
    def __init__(self, frame: types.FrameType, **kwargs) -> None: ...
    def cleanup(self) -> None: ...
    def gen_compute_in_break_with_name_store(self, restore_names, instr_idx): ...
    def transform(self): ...
    def FOR_ITER(self, instr): ...
    new_code: Incomplete
    guard_fn: Incomplete
    def RETURN_VALUE(self, instr: Instruction): ...
