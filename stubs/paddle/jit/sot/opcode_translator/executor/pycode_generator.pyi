import types
from ...utils import FallbackError as FallbackError, InnerError as InnerError, OrderedSet as OrderedSet, ResumeFnNameFactory as ResumeFnNameFactory, is_clean_code as is_clean_code, list_contain_by_id as list_contain_by_id, list_find_index_by_id as list_find_index_by_id, no_eval_frame as no_eval_frame
from ..instruction_utils import Instruction as Instruction, analysis_inputs as analysis_inputs, apply_instr_pass as apply_instr_pass, calc_stack_effect as calc_stack_effect, gen_instr as gen_instr, get_instructions as get_instructions, instrs_info as instrs_info, modify_instrs as modify_instrs, modify_vars as modify_vars
from ..instruction_utils.opcode_info import JumpDirection as JumpDirection, PYOPCODE_CACHE_SIZE as PYOPCODE_CACHE_SIZE, PopJumpCond as PopJumpCond, UNCONDITIONAL_JUMP as UNCONDITIONAL_JUMP
from .instr_flag import CALL_FUNCTION_EX_FLAG as CALL_FUNCTION_EX_FLAG
from _typeshed import Incomplete
from functools import cached_property as cached_property
from typing import Any

CODE_NAME_RNG: Incomplete

def get_pycode_attributes() -> list[str]: ...

PYCODE_ATTRIBUTES: Incomplete

def gen_code_options(code: types.CodeType) -> dict[str, Any]: ...
def gen_new_opcode(instrs: list[Instruction], code_options: dict[str, Any], keys: list[str]) -> types.CodeType: ...
def assemble(instructions: list[Instruction], firstlineno: int) -> tuple[bytes, bytes]: ...
def to_byte(num): ...
def get_instruction_size(instr: Instruction) -> int: ...
def create_linetable_calculator(firstlineno: int): ...
def compile_exception_table() -> None: ...
def stacksize(instructions: list[Instruction]) -> float: ...

class PyCodeGen:
    disable_eval_frame: Incomplete
    hooks: Incomplete
    def __init__(self, frame: types.FrameType, disable_eval_frame: bool = False) -> None: ...
    def insert_prefix_instructions(self) -> None: ...
    def update_code_name(self, fn_name, is_resumed_fn) -> None: ...
    def gen_pycode(self) -> types.CodeType: ...
    def gen_resume_fn_at(self, index: int, stack_size: int) -> tuple[None | types.FunctionType, OrderedSet[str]]: ...
    @cached_property
    def global_null_variable(self): ...
    def gen_disable_eval_frame(self) -> None: ...
    def gen_enable_eval_frame(self) -> None: ...
    def gen_outputs_and_return(self, outputs) -> None: ...
    def create_fn_with_inputs(self, inputs: list) -> types.FunctionType: ...
    def gen_load_const(self, value: Any): ...
    def gen_print_log(self, message) -> None: ...
    def gen_dbg_function(self, dbg_fun) -> None: ...
    @property
    def cell_free_storage(self): ...
    def gen_load(self, name) -> None: ...
    def gen_store(self, name, code) -> None: ...
    def gen_load_global(self, name, push_null: bool = False) -> None: ...
    def gen_load_object(self, obj, obj_name: str, push_null: bool = True): ...
    def gen_load_null_variable(self) -> None: ...
    def gen_load_fast(self, name) -> None: ...
    def gen_load_deref(self, name) -> None: ...
    def gen_load_attr(self, name: str): ...
    def gen_store_attr(self, name: str): ...
    def gen_delete_attr(self, name: str): ...
    def gen_load_method(self, name: str): ...
    def gen_delete_global(self, name: str): ...
    def gen_import_name(self, name: str): ...
    def gen_store_fast(self, name) -> None: ...
    def gen_store_global(self, name) -> None: ...
    def gen_store_deref(self, name) -> None: ...
    def gen_store_subscr(self) -> None: ...
    def gen_subscribe(self) -> None: ...
    def gen_build_tuple(self, count) -> None: ...
    def gen_build_list(self, count) -> None: ...
    def gen_build_map(self, count) -> None: ...
    def gen_build_slice(self, argc) -> None: ...
    def gen_unpack_sequence(self, count) -> None: ...
    def gen_call_function(self, argc: int = 0) -> None: ...
    def gen_call_function_ex(self, has_kwargs) -> None: ...
    def gen_call_method(self, argc: int = 0) -> None: ...
    def gen_kw_names(self, kw_names: tuple[str, ...] | None): ...
    def gen_pop_top(self) -> None: ...
    def gen_rot_n(self, n): ...
    def gen_shift_n(self, s: int, n: int): ...
    def gen_swap(self, n) -> None: ...
    def gen_jump(self, jump_to: Instruction | None = None, *, direction: JumpDirection = ...) -> Instruction: ...
    def gen_pop_jump(self, jump_to: Instruction | None = None, *, direction: JumpDirection = ..., suffix: PopJumpCond = ...) -> Instruction: ...
    def gen_return(self) -> None: ...
    def gen_get_iter(self) -> None: ...
    def gen_operator_only(self, op_name) -> None: ...
    def gen_operator(self, op_name) -> None: ...
    def gen_compare(self, cmp_op) -> None: ...
    def pprint(self) -> None: ...
    def extend_instrs(self, instrs) -> None: ...
    def pop_instr(self) -> None: ...
