from .base_transformer import BaseTransformer as BaseTransformer
from .break_continue_transformer import ForToWhileTransformer as ForToWhileTransformer
from .utils import Dygraph2StaticException as Dygraph2StaticException, ORIGI_INFO as ORIGI_INFO, ast_to_source_code as ast_to_source_code, index_in_list as index_in_list
from _typeshed import Incomplete
from paddle.base import unique_name as unique_name
from paddle.utils import gast as gast

RETURN_PREFIX: str
RETURN_VALUE_PREFIX: str
RETURN_VALUE_INIT_NAME: str

def get_return_size(return_node): ...

class ReplaceReturnNoneTransformer(BaseTransformer):
    root: Incomplete
    def __init__(self, root_node) -> None: ...
    def transform(self) -> None: ...
    def visit_Return(self, node): ...

class ReturnAnalysisVisitor(gast.NodeVisitor):
    root: Incomplete
    count_return: int
    max_return_length: int
    def __init__(self, root_node) -> None: ...
    def visit_FunctionDef(self, node) -> None: ...
    def visit_Return(self, node) -> None: ...
    def get_func_return_count(self): ...
    def get_func_max_return_length(self): ...

class ReturnTransformer(BaseTransformer):
    root: Incomplete
    def __init__(self, root) -> None: ...
    def transform(self) -> None: ...
    def visit_FunctionDef(self, node): ...

class SingleReturnTransformer(BaseTransformer):
    root: Incomplete
    ancestor_nodes: Incomplete
    return_value_name: Incomplete
    return_name: Incomplete
    pre_analysis: Incomplete
    def __init__(self, root) -> None: ...
    def assert_parent_is_not_while(self, parent_node_of_return) -> None: ...
    def generic_visit(self, node) -> None: ...
    def visit(self, node): ...
    def visit_FunctionDef(self, node): ...
    def append_assign_to_return_node(self, value, parent_node_of_return, return_name, assign_nodes) -> None: ...
    def transform(self): ...
    def visit_Return(self, node) -> None: ...
