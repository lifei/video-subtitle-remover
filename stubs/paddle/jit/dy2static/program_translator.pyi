from . import error as error, logging_utils as logging_utils
from .ast_transformer import DygraphToStaticAst as DygraphToStaticAst
from .function_spec import FunctionSpec as FunctionSpec, get_buffers as get_buffers, get_parameters as get_parameters
from .origin_info import attach_origin_info as attach_origin_info, create_and_update_origin_info_map as create_and_update_origin_info_map, update_op_callstack_with_origin_info as update_op_callstack_with_origin_info
from .partial_program import PartialProgramLayerHook as PartialProgramLayerHook
from .pir_partial_program import PartialProgramLayerHook as PirPartialProgramLayerHook
from .utils import ALREADY_D2S as ALREADY_D2S, NO_SHAPE_VAR_TYPE as NO_SHAPE_VAR_TYPE, ast_to_func as ast_to_func, backend_guard as backend_guard, func_to_source_code as func_to_source_code, input_specs_compatible as input_specs_compatible, is_paddle_func as is_paddle_func, make_hashable as make_hashable, prim_is_enabled as prim_is_enabled, prim_or_cinn_is_enabled as prim_or_cinn_is_enabled, type_name as type_name, unwrap as unwrap
from _typeshed import Incomplete
from paddle import decomposition as decomposition, get_flags as get_flags
from paddle.base import core as core, framework as framework
from paddle.base.data_feeder import check_type as check_type
from paddle.base.dygraph.base import param_guard as param_guard, switch_to_static_graph as switch_to_static_graph
from paddle.base.unique_name import UniqueNameGenerator as UniqueNameGenerator
from paddle.framework import in_dynamic_mode as in_dynamic_mode, use_pir_api as use_pir_api
from paddle.nn.layer import layers as layers
from paddle.pir import OpResult as OpResult
from paddle.static.amp.fp16_utils import AmpOptions as AmpOptions
from paddle.utils import flatten as flatten, gast as gast

MAX_TRACED_PROGRAM_COUNT: int
CONVERSION_OPTIONS: str

def synchronized(func): ...

class FunctionCache:
    def __init__(self) -> None: ...
    def convert_with_cache(self, func): ...
    def exist(self, func): ...

def convert_to_static(function): ...

class CacheKey:
    function_spec: Incomplete
    input_args_with_spec: Incomplete
    input_kwargs_with_spec: Incomplete
    class_instance: Incomplete
    kwargs: Incomplete
    def __init__(self, function_spec, input_args_with_spec, input_kwargs_with_spec, class_instance, **kwargs) -> None: ...
    @classmethod
    def from_func_and_args(cls, function_spec, args, kwargs, class_instance): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __neq__(self, other): ...

def unwrap_decorators(func): ...

class StaticFunction:
    def __init__(self, function, input_spec: Incomplete | None = None, **kwargs) -> None: ...
    @property
    def is_property(self): ...
    def train(self) -> None: ...
    def eval(self) -> None: ...
    def __get__(self, instance, owner): ...
    def __call__(self, *args, **kwargs): ...
    def get_concrete_program(self, *args, **kwargs) -> None: ...
    def get_concrete_program_with_cache_key(self, cached_key) -> None: ...
    def get_traced_count(self) -> None: ...
    @property
    def code(self) -> None: ...
    @property
    def dygraph_function(self): ...
    @property
    def concrete_program(self) -> None: ...
    def concrete_program_specify_input_spec(self, input_spec: Incomplete | None = None, with_hook: bool = False, is_prim_infer: bool = False) -> None: ...
    def rollback(self): ...
    def __deepcopy__(self, memo): ...
    @property
    def inputs(self) -> None: ...
    @property
    def outputs(self) -> None: ...
    @property
    def main_program(self) -> None: ...
    @property
    def program_cache(self) -> None: ...
    @property
    def function_spec(self) -> None: ...

def raise_error_template(func_str): ...

class SymbolicStaticFunction(StaticFunction):
    last_call_input_spec: Incomplete
    def __init__(self, function, input_spec: Incomplete | None = None, **kwargs) -> None: ...
    @property
    def code(self) -> None: ...
    @property
    def concrete_program(self) -> None: ...
    concrete_program_specify_input_spec: Incomplete
    get_concrete_program: Incomplete
    get_concrete_program_with_cache_key: Incomplete
    get_traced_count: Incomplete
    @property
    def inputs(self) -> None: ...
    @property
    def outputs(self) -> None: ...
    @property
    def main_program(self) -> None: ...
    @property
    def program_cache(self) -> None: ...
    @property
    def function_spec(self) -> None: ...

class ASTStaticFunction(StaticFunction):
    def __init__(self, function, input_spec: Incomplete | None = None, **kwargs) -> None: ...
    def get_concrete_program(self, *args, **kwargs): ...
    def get_concrete_program_with_cache_key(self, cached_key): ...
    def get_traced_count(self): ...
    @property
    def code(self): ...
    @property
    def concrete_program(self): ...
    def concrete_program_specify_input_spec(self, input_spec: Incomplete | None = None, with_hook: bool = False, is_prim_infer: bool = False): ...
    @property
    def inputs(self): ...
    @property
    def outputs(self): ...
    @property
    def main_program(self): ...
    @property
    def program_cache(self): ...
    @property
    def function_spec(self): ...

class HookHelper:
    func: Incomplete
    class_instance: Incomplete
    with_hook: Incomplete
    need_apply_hook: Incomplete
    def __init__(self, func, class_instance, with_hook: bool = False) -> None: ...
    def apply_pre_hooks(self, inputs): ...
    def apply_post_hooks(self, inputs, outputs): ...

class ConcreteProgram:
    inputs: Incomplete
    outputs: Incomplete
    main_program: Incomplete
    startup_program: Incomplete
    parameters: Incomplete
    function: Incomplete
    name_generator: Incomplete
    kwargs: Incomplete
    def __init__(self, inputs, outputs, parameters, function, name_generator, main_program, startup_program: Incomplete | None = None, **kwargs) -> None: ...
    @staticmethod
    def pir_from_func_spec(func_spec, input_spec, input_kwargs_spec, class_instance, **kwargs): ...
    @staticmethod
    def from_func_spec(func_spec, input_spec, input_kwargs_spec, class_instance, **kwargs): ...

class ParametersRecorder:
    params_dict: Incomplete
    def __init__(self) -> None: ...
    def add(self, program, param) -> None: ...
    def pop(self, program): ...

class InplaceMap:
    params_dict: Incomplete
    def __init__(self) -> None: ...
    def add(self, program, id, param) -> None: ...
    def get(self, program, id): ...
    def restore_checkpoint(self, checkpoint) -> None: ...
    def save_checkpoint(self): ...

class FallbackProgramLayer:
    def __init__(self, instance, dy_func) -> None: ...
    def __call__(self, inputs): ...
    def __getattr__(self, key): ...
    def __setattr__(self, key, value): ...

class PirPrimHooker(PirPartialProgramLayerHook):
    backend: Incomplete
    custom_vjps: Incomplete
    def __init__(self, original_program, backend) -> None: ...
    def before_append_backward(self, forward_program, src_vars): ...
    def after_append_backward(self, whole_program, src_vars, forward_end_idx): ...
    def after_infer(self, infer_program) -> None: ...

class ProgramCache:
    dy2static_error_file: str
    def __init__(self) -> None: ...
    def __getitem__(self, item): ...
    def get_program_without_cache(self, cache_key): ...
    def get_program(self, item): ...
    def last(self): ...
    def __len__(self) -> int: ...
    def concrete_programs(self): ...
    def clear(self) -> None: ...

class PrimHooker(PartialProgramLayerHook):
    backend: Incomplete
    custom_vjps: Incomplete
    def __init__(self, original_program, backend) -> None: ...
    def before_append_backward(self, forward_program): ...
    def after_append_backward(self, whole_program, backward_start_idx): ...
    def after_infer(self, infer_program): ...

class ProgramTranslator:
    def __new__(cls, *args, **kwargs): ...
    @classmethod
    def get_instance(cls): ...
    @classmethod
    def reset(cls) -> None: ...
    enable_to_static: bool
    def __init__(self) -> None: ...
    def enable(self, enable_to_static) -> None: ...

def enable_to_static(enable_to_static_bool) -> None: ...
