from .ast_utils import ast_to_source_code as ast_to_source_code
from .static_analysis import StaticAnalysisVisitor as StaticAnalysisVisitor
from .utils_helper import DYGRAPH_MODULE_PREFIX as DYGRAPH_MODULE_PREFIX, DYGRAPH_TO_STATIC_MODULE_PREFIX as DYGRAPH_TO_STATIC_MODULE_PREFIX, NodeVarType as NodeVarType, PADDLE_MODULE_PREFIX as PADDLE_MODULE_PREFIX, index_in_list as index_in_list, is_api_in_module as is_api_in_module, is_dygraph_api as is_dygraph_api, is_numpy_api as is_numpy_api, is_paddle_api as is_paddle_api
from _typeshed import Incomplete
from collections.abc import Generator
from paddle import base as base, get_flags as get_flags, set_flags as set_flags
from paddle.base import backward as backward, core as core, framework as framework, unique_name as unique_name
from paddle.base.data_feeder import convert_dtype as convert_dtype
from paddle.base.layer_helper import LayerHelper as LayerHelper
from paddle.base.wrapped_decorator import signature_safe_contextmanager as signature_safe_contextmanager
from paddle.utils import gast as gast

GET_ARGS_FUNC_PREFIX: str
SET_ARGS_FUNC_PREFIX: str
ALREADY_D2S: str
ARGS_NAME: str
ORIGI_INFO: str
DEL_TEMP_DIR: bool
FOR_ITER_INDEX_PREFIX: str
FOR_ITER_TUPLE_PREFIX: str
FOR_ITER_TARGET_PREFIX: str
FOR_ITER_ITERATOR_PREFIX: str
FOR_ITER_TUPLE_INDEX_PREFIX: str
FOR_ITER_VAR_LEN_PREFIX: str
FOR_ITER_VAR_NAME_PREFIX: str
FOR_ITER_ZIP_TO_LIST_PREFIX: str
RE_PYNAME: str
RE_PYMODULE: str
RETURN_NO_VALUE_VAR_NAME: str
RETURN_NO_VALUE_MAGIC_NUM: float
TRUE_FUNC_PREFIX: str
FALSE_FUNC_PREFIX: str
WHILE_CONDITION_PREFIX: str
WHILE_BODY_PREFIX: str
FOR_CONDITION_PREFIX: str
FOR_BODY_PREFIX: str
GRAD_PREFIX: str
GRAD_SUFFIX: str
NO_SHAPE_VAR_TYPE: Incomplete

class BaseNodeVisitor(gast.NodeVisitor):
    ancestor_nodes: Incomplete
    def __init__(self) -> None: ...
    def visit(self, node): ...

dygraph_class_to_static_api: Incomplete

def data_layer_not_check(name, shape, dtype: str = 'float32', lod_level: int = 0): ...
def create_undefined_variable(): ...

class UndefinedVar:
    name: Incomplete
    def __init__(self, name) -> None: ...
    def check(self) -> None: ...

class Dygraph2StaticException(Exception):
    def __init__(self, message) -> None: ...

def saw(x): ...
def parse_arg_and_kwargs(function): ...
def parse_varargs_name(function): ...
def type_name(v): ...
def make_hashable(x, error_msg: Incomplete | None = None): ...

AS_NOT_INNER_FUNC_LIST: Incomplete

def as_not_paddle_func(path) -> None: ...
def is_paddle_func(func, ignore_white_list: bool = True): ...
def to_static_api(dygraph_class): ...
def to_static_ast(node, class_node): ...
def update_args_of_func(node, dygraph_node, method_name) -> None: ...
def create_api_shape_node(tensor_shape_node): ...
def get_constant_variable_node(name, value, shape=[1], dtype: str = 'int64'): ...
def get_attribute_full_name(node): ...
def generate_name_node(name_ids, ctx=..., gen_tuple_if_single: bool = False): ...
def create_funcDef_node(nodes, name, input_args, return_name_ids): ...
def create_assign_node(name, node): ...
def get_temp_dir(): ...
def ast_to_func(ast_root, dyfunc, delete_on_exit: bool = True): ...
def recover_globals_attribute(src_obj, dst_obj) -> None: ...
def func_to_source_code(function, dedent: bool = True): ...
def is_candidate_node(node): ...
def compare_with_none(node): ...

class IsControlFlowVisitor(gast.NodeVisitor):
    ast_root: Incomplete
    static_analysis_visitor: Incomplete
    node_to_wrapper_map: Incomplete
    node_var_type_map: Incomplete
    is_control_flow_num: int
    def __init__(self, ast_node, static_analysis_visitor: Incomplete | None = None, node_var_type_map: Incomplete | None = None) -> None: ...
    def transform(self): ...
    def visit_BoolOp(self, node): ...
    def visit_Compare(self, node): ...
    def visit_Call(self, node): ...
    def visit_Name(self, node): ...
    def visit_Constant(self, node): ...
    def get_compare_nodes_with_tensor(self): ...

def unwrap(func): ...
def input_specs_compatible(src_input_specs, desired_input_specs): ...

class NameScope:
    globals: Incomplete
    nonlocals: Incomplete
    args: Incomplete
    father: Incomplete
    w_vars: Incomplete
    created: Incomplete
    push_pop_vars: Incomplete
    def __init__(self) -> None: ...
    def set_father(self, father) -> None: ...
    def existed_vars(self): ...
    def created_vars(self): ...
    def modified_vars(self): ...
    def variadic_length_vars(self): ...
    def control_flow_vars(self): ...
    def is_global_var(self, name): ...
    def is_local_var(self, name): ...
    def merge_from(self, name_scope) -> None: ...

class FunctionNameLivenessAnalysis(gast.NodeVisitor):
    scope_node_stack: Incomplete
    def __init__(self, root_node) -> None: ...
    def visit_ListComp(self, node) -> None: ...
    def visit_DictComp(self, node) -> None: ...
    def visit_Name(self, node) -> None: ...
    def visit_FunctionDef(self, node): ...
    def visit_For(self, node) -> None: ...
    def visit_While(self, node) -> None: ...
    def visit_If(self, node) -> None: ...
    def visit_Global(self, node) -> None: ...
    def visit_Nonlocal(self, node) -> None: ...
    def visit_Attribute(self, node) -> None: ...
    def visit_Subscript(self, node) -> None: ...
    def visit_Call(self, node) -> None: ...

def create_get_args_node(names): ...
def create_set_args_node(names): ...
def create_nonlocal_stmt_nodes(names): ...

class GetterSetterHelper:
    getter: Incomplete
    setter: Incomplete
    name2id: Incomplete
    def __init__(self, getter_func, setter_func, *name_lists) -> None: ...
    def union(self): ...
    def get(self, names): ...
    def set(self, names, values) -> None: ...

def create_name_str(name_ids): ...
def prim_or_cinn_is_enabled(build_strategy, backend): ...
def cinn_is_enabled(build_strategy, backend): ...
def prim_is_enabled(): ...
def is_builtin(func, name: Incomplete | None = None): ...
def backend_guard(backend) -> Generator[None]: ...
def construct_grad_names(grad_info_map, x_vars, param_vars, out_vars): ...
def tensor_name_guard(tensors, names) -> Generator[None]: ...
