import enum
from _typeshed import Incomplete

__all__ = ['Transform', 'AbsTransform', 'AffineTransform', 'ChainTransform', 'ExpTransform', 'IndependentTransform', 'PowerTransform', 'ReshapeTransform', 'SigmoidTransform', 'SoftmaxTransform', 'StackTransform', 'StickBreakingTransform', 'TanhTransform']

class Type(enum.Enum):
    BIJECTION = 'bijection'
    INJECTION = 'injection'
    SURJECTION = 'surjection'
    OTHER = 'other'
    @classmethod
    def is_injective(cls, _type): ...

class Transform:
    def __init__(self) -> None: ...
    def __call__(self, input): ...
    def forward(self, x): ...
    def inverse(self, y): ...
    def forward_log_det_jacobian(self, x): ...
    def inverse_log_det_jacobian(self, y): ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class AbsTransform(Transform): ...

class AffineTransform(Transform):
    def __init__(self, loc, scale) -> None: ...
    @property
    def loc(self): ...
    @property
    def scale(self): ...

class ChainTransform(Transform):
    transforms: Incomplete
    def __init__(self, transforms) -> None: ...

class ExpTransform(Transform):
    def __init__(self) -> None: ...

class IndependentTransform(Transform):
    def __init__(self, base, reinterpreted_batch_rank) -> None: ...

class PowerTransform(Transform):
    def __init__(self, power) -> None: ...
    @property
    def power(self): ...

class ReshapeTransform(Transform):
    def __init__(self, in_event_shape, out_event_shape) -> None: ...
    @property
    def in_event_shape(self): ...
    @property
    def out_event_shape(self): ...

class SigmoidTransform(Transform): ...
class SoftmaxTransform(Transform): ...

class StackTransform(Transform):
    def __init__(self, transforms, axis: int = 0) -> None: ...
    @property
    def transforms(self): ...
    @property
    def axis(self): ...

class StickBreakingTransform(Transform): ...
class TanhTransform(Transform): ...
