from _typeshed import Incomplete
from paddle.base import core as core
from paddle.base.framework import Operator as Operator, Program as Program, Variable as Variable, in_pir_mode as in_pir_mode, static_only as static_only
from paddle.base.libpaddle.pir import build_if_op as build_if_op, build_while_op as build_while_op, cf_yield as cf_yield
from paddle.common_ops_import import LayerHelper as LayerHelper, check_type as check_type, check_variable_and_dtype as check_variable_and_dtype, convert_dtype as convert_dtype, in_dygraph_mode as in_dygraph_mode
from paddle.utils import assert_same_structure as assert_same_structure, copy_mutable_vars as copy_mutable_vars, flatten as flatten, hold_mutable_vars as hold_mutable_vars, is_sequence as is_sequence, map_structure as map_structure, pack_sequence_as as pack_sequence_as, to_sequence as to_sequence

def Assert(cond, data: Incomplete | None = None, summarize: int = 20, name: Incomplete | None = None): ...

class BlockGuard:
    main_program: Incomplete
    def __init__(self, main_program) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...

class WhileGuard(BlockGuard):
    while_op: Incomplete
    def __init__(self, while_op) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...

class ConditionalBlock:
    inputs: Incomplete
    is_scalar_condition: Incomplete
    helper: Incomplete
    def __init__(self, inputs, is_scalar_condition: bool = False, name: Incomplete | None = None) -> None: ...
    def block(self): ...
    def complete(self) -> None: ...
    def need_append_conditional_block_grad(self, inside_block): ...
    def append_conditional_block_grad(self, parent_block, inside_block, conditional_block_op) -> None: ...

class ConditionalBlockGuard(BlockGuard):
    block: Incomplete
    def __init__(self, block) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...

def get_inputs_outputs_in_block(current_block, inner_inputs, inner_outputs, helper): ...

class While:
    BEFORE_WHILE_BLOCK: int
    IN_WHILE_BLOCK: int
    AFTER_WHILE_BLOCK: int
    helper: Incomplete
    status: Incomplete
    cond_var: Incomplete
    is_test: Incomplete
    def __init__(self, cond, is_test: bool = False, name: Incomplete | None = None) -> None: ...
    def block(self): ...

support_ret_buildin_type: Incomplete

def assign_skip_lod_tensor_array(input, output): ...
def while_loop(cond, body, loop_vars, is_test: bool = False, name: Incomplete | None = None): ...
def case(pred_fn_pairs, default: Incomplete | None = None, name: Incomplete | None = None): ...
def switch_case(branch_index, branch_fns, default: Incomplete | None = None, name: Incomplete | None = None): ...
def cond(pred, true_fn: Incomplete | None = None, false_fn: Incomplete | None = None, name: Incomplete | None = None, return_names: Incomplete | None = None): ...
def copy_var_to_parent_block(var, layer_helper): ...
def select_output(input, outputs, mask): ...
def select_input(inputs, mask): ...
def select_input_with_buildin_type(inputs, mask, name): ...
def expand_undefined_var(nest1, nest2, names): ...
def change_none_to_undefinedvar(nest1, nest2): ...
def Print(input, first_n: int = -1, message: Incomplete | None = None, summarize: int = 20, print_tensor_name: bool = True, print_tensor_type: bool = True, print_tensor_shape: bool = True, print_tensor_layout: bool = True, print_tensor_lod: bool = True, print_phase: str = 'both'): ...

class Switch:
    helper: Incomplete
    inside_scope: bool
    pre_not_conditions: Incomplete
    def __init__(self, name: Incomplete | None = None) -> None: ...
    def case(self, condition): ...
    def default(self): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...
