from ..base.data_feeder import check_type as check_type, check_variable_and_dtype as check_variable_and_dtype
from ..base.framework import in_dynamic_or_pir_mode as in_dynamic_or_pir_mode
from ..base.layer_helper import LayerHelper as LayerHelper
from .linalg import matmul as matmul, transpose as transpose
from .manipulation import reshape as reshape, squeeze as squeeze, unsqueeze as unsqueeze
from .math import multiply as multiply
from _typeshed import Incomplete

def parse_op_labels(labelstr, operand): ...
def parse_labels(labelstr, operands): ...
def validate_rhs(rhs, input_labels, n_bcast_dims) -> None: ...
def build_view(in_labels, out_labels): ...
def build_global_view(nop_labels, rhs, n_bcast_dims): ...
def build_global_shape(g_view, g_labels, op_shapes): ...
def has_duplicated_labels(labels): ...
def diagonalize(labels, operand): ...
def plan_reduce(plan, op, reduce_dims, keepdim): ...
def plan_scalar_prod(plan, op1, op2): ...
def plan_matmul(plan, g_view, op1, op2, g_supports, g_shape, I, J1, J2, K) -> None: ...
def plan_summation(plan, g_view, op1, op2, g_supports, g_shape, g_count, n_bcast) -> None: ...
def rearrange(axes): ...
def plan_broadcast(plan, operands, nop_axes): ...

class Plan:
    env: Incomplete
    steps: Incomplete
    def __init__(self) -> None: ...
    def add_step(self, step) -> None: ...
    def get_var(self, varname): ...
    def set_var(self, varname, var) -> None: ...
    def show(self): ...
    def execute(self): ...

def plan_einsum(operands, g_view, g_shape, g_supports, g_count, n_bcast): ...
def preprocess(equation, *operands): ...
def parse_fake_shape(equation, operands, labels): ...
def rhs_inference(lhs): ...
def gen_equation_for_opteinsum(lhs, rhs): ...
def einsum_v2(equation, *operands): ...
def gen_einsum_op(equation, *operands): ...
def einsum(equation, *operands): ...
