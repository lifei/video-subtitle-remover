from .callbacks import EarlyStopping as EarlyStopping, config_callbacks as config_callbacks
from .model_summary import summary as summary
from _typeshed import Incomplete
from paddle import base as base
from paddle.autograd import no_grad as no_grad
from paddle.base import core as core
from paddle.base.dygraph.base import to_variable as to_variable
from paddle.base.executor import global_scope as global_scope
from paddle.base.framework import Variable as Variable
from paddle.distributed import fleet as fleet
from paddle.distributed.fleet.base import role_maker as role_maker
from paddle.framework import in_dynamic_mode as in_dynamic_mode
from paddle.framework.io_utils import is_belong_to_optimizer as is_belong_to_optimizer
from paddle.io import DataLoader as DataLoader, Dataset as Dataset, DistributedBatchSampler as DistributedBatchSampler
from paddle.jit.translated_layer import INFER_MODEL_SUFFIX as INFER_MODEL_SUFFIX, INFER_PARAMS_SUFFIX as INFER_PARAMS_SUFFIX
from paddle.metric import Metric as Metric

def to_list(value): ...
def to_numpy(var): ...
def flatten_list(l): ...
def restore_flatten_list(l, splits): ...
def extract_args(func): ...
def wait_server_ready(endpoints) -> None: ...
def init_communicator(program, rank, nranks, wait_port, current_endpoint, endpoints) -> None: ...
def prepare_distributed_context(place: Incomplete | None = None): ...

class StaticGraphAdapter:
    model: Incomplete
    def __init__(self, model) -> None: ...
    @property
    def mode(self): ...
    @mode.setter
    def mode(self, value) -> None: ...
    def train_batch(self, inputs, labels: Incomplete | None = None, update: bool = True): ...
    def eval_batch(self, inputs, labels: Incomplete | None = None): ...
    def predict_batch(self, inputs): ...
    def parameters(self, *args, **kwargs): ...
    def save(self, path) -> None: ...
    def load(self, param_state_pairs, optim_state) -> None: ...
    def prepare(self) -> None: ...

class DynamicGraphAdapter:
    model: Incomplete
    ddp_model: Incomplete
    def __init__(self, model) -> None: ...
    @property
    def mode(self): ...
    @mode.setter
    def mode(self, value) -> None: ...
    def train_batch(self, inputs, labels: Incomplete | None = None, update: bool = True): ...
    def eval_batch(self, inputs, labels: Incomplete | None = None): ...
    def predict_batch(self, inputs): ...
    def parameters(self, *args, **kwargs): ...
    def save(self, path) -> None: ...
    def load(self, param_state_pairs, optim_state, scaler_state: Incomplete | None = None): ...
    def prepare(self) -> None: ...

class Model:
    mode: str
    network: Incomplete
    stop_training: bool
    def __init__(self, network, inputs: Incomplete | None = None, labels: Incomplete | None = None) -> None: ...
    def train_batch(self, inputs, labels: Incomplete | None = None, update: bool = True): ...
    def eval_batch(self, inputs, labels: Incomplete | None = None): ...
    def predict_batch(self, inputs): ...
    def save(self, path, training: bool = True) -> None: ...
    def load(self, path, skip_mismatch: bool = False, reset_optimizer: bool = False): ...
    def parameters(self, *args, **kwargs): ...
    def prepare(self, optimizer: Incomplete | None = None, loss: Incomplete | None = None, metrics: Incomplete | None = None, amp_configs: Incomplete | None = None) -> None: ...
    num_iters: Incomplete
    def fit(self, train_data: Incomplete | None = None, eval_data: Incomplete | None = None, batch_size: int = 1, epochs: int = 1, eval_freq: int = 1, log_freq: int = 10, save_dir: Incomplete | None = None, save_freq: int = 1, verbose: int = 2, drop_last: bool = False, shuffle: bool = True, num_workers: int = 0, callbacks: Incomplete | None = None, accumulate_grad_batches: int = 1, num_iters: Incomplete | None = None) -> None: ...
    def evaluate(self, eval_data, batch_size: int = 1, log_freq: int = 10, verbose: int = 2, num_workers: int = 0, callbacks: Incomplete | None = None, num_iters: Incomplete | None = None): ...
    def predict(self, test_data, batch_size: int = 1, num_workers: int = 0, stack_outputs: bool = False, verbose: int = 1, callbacks: Incomplete | None = None): ...
    def summary(self, input_size: Incomplete | None = None, dtype: Incomplete | None = None): ...
